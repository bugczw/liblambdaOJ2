from ctypes import CDLL, pointer, c_int, c_long, c_char_p, Structure
from .consts import COMPILERS


class TaskResult(Structure):
    _fields_ = [("final_result", c_int),
                ("time_used", c_long),
                ("mem_used", c_int)]


class Judge:
    """
    This class implements the Python API for the C lib lambdaOJ2.

    The object is initialized by a python dict object: json_obj
    The filed and type of this dict object is:
    {
      "compiler_name": string,
      "exe_file": string, (full path of the executable file generated by compiler)
      "err_log": string, (full path of the file of error message when compiling)
      "source_code": string, (full path of the code submitted),
      "sample_num", integer(the number of total test sample),
      "mem_limit", integer(the memory limit, in KBytes),
      "time_limit", integer(the time limit, in Seconds)
    }

    The main method of this class is:
    * compile()
      return_type: integer, COMPILE_OK or COMPILE_ERROR(defined in consts.py)
    * run_task()
      return_type: list of TaskResult
    """

    def __init__(self, json_obj):
        self.json_obj = json_obj

        clib_lambdaOj2 = CDLL("liblambdaOJ2.so")
        self.compile_func = clib_lambdaOj2.compile
        self.run_task_func = clib_lambdaOj2.run_task_under_monitor

    def _get_char_p(self, key):
        return c_char_p(bytes(self.json_obj.get(key, ""), "utf-8"))

    def compile(self):
        source_code = self._get_char_p("source_code")
        exe_file = self._get_char_p("exe_file")
        err_log = self._get_char_p("err_log")

        compiler_name = self.json_obj.get("compiler_name", "")
        compiler = c_int(COMPILERS.get(compiler_name, -1))

        compile_result = self.compile_func(source_code,
                                           exe_file,
                                           compiler,
                                           err_log)

        return compile_result

    def run_task(self):
        total_sample_num = self.json_obj.get("sample_num", 1)
        results = [TaskResult() for i in range(total_sample_num)]
        for id, result in enumerate(results):
            self._run_task_with_id(id, pointer(result))
        return results

    def _run_task_with_id(self, id, point_of_tr):
        exe_file = self._get_char_p("exe_file")
        input_file = self._get_input_file_from_id(id)
        output_file = self._get_input_file_from_id(id)
        time_limit = c_int(self.json_obj.get("time_limit", 1))
        mem_limit = c_int(self.json_obj.get("mem_limit", 1024*10))

        self.run_task_func(exe_file, input_file, output_file,
                           time_limit, mem_limit, point_of_tr)

    def _get_input_file_from_id(self, id):
        return "/tmp/test.c"

    def _get_output_file_from_id(self, id):
        return "/tmp/out"

    def clear_compile_space(self):
        pass

    def clear_run_space(self):
        pass
